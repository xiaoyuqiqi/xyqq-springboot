
## 🌱 一、使用方法

### 1. 声明式事务（Declarative Transaction）

> 借助 Spring 提供的 AOP（面向切面编程）机制，通过注解或 XML 配置的方式声明事务规则。

**最常用方式：**

* 使用 `@Transactional` 注解在类或方法上：

```java
@Service
public class UserService {
    @Transactional
    public void addUser(User user) {
        // 执行业务逻辑
    }
}
```

* 配置式（较少使用）：在 XML 中使用 `<tx:advice>`、`<aop:config>` 等标签配置切面。

**适用场景：**

* 业务方法中主要是数据库 CRUD，不需要对事务做复杂控制。

---

### 2. 编程式事务（Programmatic Transaction）

> 通过代码显式控制事务的开始、提交和回滚。

**常用方式：**

* 使用 `TransactionTemplate`：

```java
@Autowired
private TransactionTemplate transactionTemplate;

public void addUser(User user) {
    transactionTemplate.execute(status -> {
        // 执行业务逻辑
        return null;
    });
}
```

* 使用 `PlatformTransactionManager`：

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void addUser(User user) {
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(def);
    try {
        // 执行业务逻辑
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw e;
    }
}
```

**适用场景：**

* 对同一方法的不同部分需要不同的事务控制。
* 需要灵活控制事务边界或条件回滚。

---

## ⚖️ 二、优缺点对比

| 对比项    | 声明式事务                       | 编程式事务              |
| ------ | --------------------------- | ------------------ |
| **优点** | 简单易用，代码清晰，解耦业务和事务控制         | 灵活精细，可控制更复杂事务场景    |
| **缺点** | 无法处理非常复杂的场景（如一个方法中部分提交部分回滚） | 代码侵入性强，可读性差，增加维护成本 |
| **适合** | 常见的单一事务场景                   | 需要复杂事务控制或动态事务决策    |

---

## 🧩 三、常见问题

### 1. @Transactional 注解失效的常见原因

* 方法是 `private`：Spring AOP 默认只对 `public` 方法生效。
* 调用的是同类中的另一个方法（**self-invocation**），事务拦截器不会生效。
* 没有被 Spring 管理（非 Spring Bean）。
* 异常被捕获后没有继续抛出：事务需要检测到未处理的 `RuntimeException` 或 `Error` 才会回滚。
* 配置的事务传播行为、隔离级别不正确。

---

### 2. 编程式事务常见问题

* 手动提交和回滚代码易遗漏。
* 和声明式事务混用时容易冲突或产生不可预期的事务嵌套。

---

## 🛠️ 四、总结

* **推荐**：常规业务场景尽量用 **声明式事务**，简单、维护成本低。
* **需要复杂控制**（如方法内不同部分事务隔离、条件性回滚）时，再考虑 **编程式事务**。
* 开发时要关注 **异常传播**、**事务传播行为** 和 **事务注解失效场景**。

---
