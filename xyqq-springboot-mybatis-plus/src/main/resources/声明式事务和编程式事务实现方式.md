下面是 **Spring 框架中事务的底层实现方式**，结合声明式事务、编程式事务、AOP 和事务管理器的原理

---

## 🌱 一、核心原理概览

Spring 的事务管理本质上基于 **AOP（面向切面编程）** 和 **事务抽象（Transaction Abstraction）** 两大核心：

* **AOP**：拦截业务方法调用，在方法执行前后开启、提交或回滚事务。
* **抽象事务管理器**：提供统一的事务处理接口，对底层不同的事务资源（如 JDBC、JPA、JTA 等）进行适配。

---

## 🧩 二、声明式事务的底层实现

### 1. @Transactional 注解背后的拦截器

* Spring 在启动时会解析 `@Transactional` 注解。
* 通过 `TransactionInterceptor`（事务拦截器）结合 Spring AOP 或 AspectJ，拦截加了 `@Transactional` 的方法调用。
* 拦截器执行时：

    1. 根据注解信息获取事务属性（比如事务传播行为、隔离级别、只读等）。
    2. 通过 `PlatformTransactionManager` 开启事务（getTransaction）。
    3. 执行业务方法。
    4. 如果方法抛出未捕获的 `RuntimeException` 或 `Error`，则回滚事务；否则提交事务。

---

### 2. 动态代理

* Spring AOP 默认基于 **JDK 动态代理**（接口）或 **CGLIB**（类代理）生成代理对象。
* 对外暴露的其实是代理对象，调用方法时进入代理 -> 执行拦截器链 -> 调用目标方法。

---

## 🛠 三、编程式事务的底层实现

### 1. TransactionTemplate

* `TransactionTemplate` 是 Spring 提供的模板类，内部封装了 `PlatformTransactionManager` 的逻辑。
* 执行 `execute()` 方法时：

    1. 调用 `PlatformTransactionManager.getTransaction()` 开启事务。
    2. 调用回调里的业务逻辑。
    3. 根据回调是否抛出异常，决定调用 `commit()` 或 `rollback()`。

示例：

```java
transactionTemplate.execute(status -> {
    // 业务逻辑
    return null;
});
```

---

### 2. PlatformTransactionManager

这是 Spring 事务抽象的核心接口：

* `getTransaction(TransactionDefinition definition)`：开启或加入事务。
* `commit(TransactionStatus status)`：提交事务。
* `rollback(TransactionStatus status)`：回滚事务。

根据不同的数据访问技术有不同的实现：

| 实现类                          | 场景         |
| ---------------------------- | ---------- |
| DataSourceTransactionManager | JDBC       |
| JpaTransactionManager        | JPA        |
| HibernateTransactionManager  | Hibernate  |
| JtaTransactionManager        | 分布式事务（JTA） |

---

## ⚙️ 四、事务传播与隔离的实现

在方法调用时，`TransactionInterceptor` 根据注解上的事务传播行为（如 REQUIRED, REQUIRES\_NEW）和当前线程绑定的事务状态决定：

* 是否新建事务
* 加入当前事务
* 不使用事务

> Spring 使用 `TransactionSynchronizationManager` 结合 ThreadLocal，把当前事务上下文与线程绑定。

---

## 🧬 五、事务状态的存储

### ThreadLocal

* 当前线程的事务信息（如 TransactionStatus、连接等）存储在线程上下文中。
* 这样一个线程在执行同一个事务时，总能获取到同一个连接和状态。

---

## 📦 六、总结流程（声明式事务）

简单流程：
1️⃣ Spring 容器加载时解析 `@Transactional` -> 注册事务拦截器
2️⃣ 调用被代理的方法
3️⃣ 拦截器先 `getTransaction()` 开启/获取事务
4️⃣ 执行业务代码
5️⃣ 根据结果或异常调用 `commit()` 或 `rollback()`
6️⃣ 清理事务资源（解绑 ThreadLocal）

---

## ✅ 七、优点

* 解耦业务逻辑与事务管理
* 支持多种持久化技术
* 通过统一接口管理不同事务实现

---

